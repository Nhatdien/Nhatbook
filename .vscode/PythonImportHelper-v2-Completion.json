[
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Annotated",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "sqlalchemy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine_from_config",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "pool",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ARRAY",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "TIMESTAMP",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "MutableList",
        "importPath": "sqlalchemy.ext.mutable",
        "description": "sqlalchemy.ext.mutable",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.mutable",
        "documentation": {}
    },
    {
        "label": "fileConfig",
        "importPath": "logging.config",
        "description": "logging.config",
        "isExtraImport": true,
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "api.config",
        "description": "api.config",
        "isExtraImport": true,
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "sqlalchemy.orm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "api.db.database",
        "description": "api.db.database",
        "isExtraImport": true,
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "api.models",
        "description": "api.models",
        "isExtraImport": true,
        "detail": "api.models",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "api.models",
        "description": "api.models",
        "isExtraImport": true,
        "detail": "api.models",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "api.models",
        "description": "api.models",
        "isExtraImport": true,
        "detail": "api.models",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "api.models",
        "description": "api.models",
        "isExtraImport": true,
        "detail": "api.models",
        "documentation": {}
    },
    {
        "label": "database",
        "importPath": "api.db",
        "description": "api.db",
        "isExtraImport": true,
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "database",
        "importPath": "api.db",
        "description": "api.db",
        "isExtraImport": true,
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "database",
        "importPath": "api.db",
        "description": "api.db",
        "isExtraImport": true,
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "database",
        "importPath": "api.db",
        "description": "api.db",
        "isExtraImport": true,
        "detail": "api.db",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "jsonable_encoder",
        "importPath": "fastapi.encoders",
        "description": "fastapi.encoders",
        "isExtraImport": true,
        "detail": "fastapi.encoders",
        "documentation": {}
    },
    {
        "label": "jsonable_encoder",
        "importPath": "fastapi.encoders",
        "description": "fastapi.encoders",
        "isExtraImport": true,
        "detail": "fastapi.encoders",
        "documentation": {}
    },
    {
        "label": "jsonable_encoder",
        "importPath": "fastapi.encoders",
        "description": "fastapi.encoders",
        "isExtraImport": true,
        "detail": "fastapi.encoders",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "RedirectResponse",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "RedirectResponse",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "RedirectResponse",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "isExtraImport": true,
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "TokenData",
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "isExtraImport": true,
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "isExtraImport": true,
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "TokenData",
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "isExtraImport": true,
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "isExtraImport": true,
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "isExtraImport": true,
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "isExtraImport": true,
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "DatabaseError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "DataError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "Post",
        "importPath": "api.models.models",
        "description": "api.models.models",
        "isExtraImport": true,
        "detail": "api.models.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "api.models.models",
        "description": "api.models.models",
        "isExtraImport": true,
        "detail": "api.models.models",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "isExtraImport": true,
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "user",
        "importPath": "api.schemas",
        "description": "api.schemas",
        "isExtraImport": true,
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "UserResponse",
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "isExtraImport": true,
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserInDb",
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "isExtraImport": true,
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserBase",
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "isExtraImport": true,
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordRequestForm",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "user",
        "importPath": "api.routes",
        "description": "api.routes",
        "isExtraImport": true,
        "detail": "api.routes",
        "documentation": {}
    },
    {
        "label": "login",
        "importPath": "api.routes",
        "description": "api.routes",
        "isExtraImport": true,
        "detail": "api.routes",
        "documentation": {}
    },
    {
        "label": "post",
        "importPath": "api.routes",
        "description": "api.routes",
        "isExtraImport": true,
        "detail": "api.routes",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "alembic.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "alembic.config",
        "description": "alembic.config",
        "detail": "alembic.config",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "starlette.testclient",
        "description": "starlette.testclient",
        "isExtraImport": true,
        "detail": "starlette.testclient",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "api.main",
        "description": "api.main",
        "isExtraImport": true,
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "SQL_BASE",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "InMemoryTodoRepository",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "SQLTodoRepository",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "Todo",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "TodoFilter",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "TodoRepository",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "get_engine",
        "importPath": "api.repository",
        "description": "api.repository",
        "isExtraImport": true,
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "alembic.versions.b9594a8b3701_create_user_table",
        "description": "alembic.versions.b9594a8b3701_create_user_table",
        "peekOfCode": "def upgrade() -> None:\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('email', sa.String(255), nullable=False, unique=True),\n        sa.Column('username', sa.String(255), nullable=False, unique=True),\n        sa.Column('password', sa.String(255), nullable=False),\n        sa.Column('created_at', sa.DateTime, nullable=True, server_default=sa.func.now()),\n        sa.Column('updated_at', sa.DateTime, nullable=True, server_default=sa.func.now(), onupdate=sa.func.now())\n    )",
        "detail": "alembic.versions.b9594a8b3701_create_user_table",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "alembic.versions.b9594a8b3701_create_user_table",
        "description": "alembic.versions.b9594a8b3701_create_user_table",
        "peekOfCode": "def downgrade() -> None:\n    op.drop_table('users')",
        "detail": "alembic.versions.b9594a8b3701_create_user_table",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "alembic.versions.d35bfb39b91c_create_post_table",
        "description": "alembic.versions.d35bfb39b91c_create_post_table",
        "peekOfCode": "def upgrade() -> None:\n    op.create_table(\n        \"post\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"content\", sa.String(), nullable=True),\n        sa.Column(\"author_id\", sa.Integer, sa.ForeignKey(\"users.id\", ondelete=\"CASCADE\", onupdate=\"NO ACTION\"),\n                   nullable=False),\n        #replied to\n        sa.Column(\"replied_to_id\", sa.Integer, sa.ForeignKey(\"post.id\",  ondelete=\"CASCADE\", onupdate=\"NO ACTION\"),\n                   nullable=True),",
        "detail": "alembic.versions.d35bfb39b91c_create_post_table",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "alembic.versions.d35bfb39b91c_create_post_table",
        "description": "alembic.versions.d35bfb39b91c_create_post_table",
        "peekOfCode": "def downgrade() -> None:\n    op.drop_table(\"post\")",
        "detail": "alembic.versions.d35bfb39b91c_create_post_table",
        "documentation": {}
    },
    {
        "label": "run_migrations_offline",
        "kind": 2,
        "importPath": "alembic.env",
        "description": "alembic.env",
        "peekOfCode": "def run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")",
        "detail": "alembic.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_online",
        "kind": 2,
        "importPath": "alembic.env",
        "description": "alembic.env",
        "peekOfCode": "def run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )",
        "detail": "alembic.env",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "alembic.env",
        "description": "alembic.env",
        "peekOfCode": "config = context.config\n# config.set_main_option(\"sqlalchemy.url\", settings.database_url)\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata",
        "detail": "alembic.env",
        "documentation": {}
    },
    {
        "label": "target_metadata",
        "kind": 5,
        "importPath": "alembic.env",
        "description": "alembic.env",
        "peekOfCode": "target_metadata = None\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation",
        "detail": "alembic.env",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "api.db.database",
        "description": "api.db.database",
        "peekOfCode": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "SQLALCHEMY_DATABASE_URL",
        "kind": 5,
        "importPath": "api.db.database",
        "description": "api.db.database",
        "peekOfCode": "SQLALCHEMY_DATABASE_URL = settings.database_url\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db",
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "api.db.database",
        "description": "api.db.database",
        "peekOfCode": "engine = create_engine(\n    SQLALCHEMY_DATABASE_URL\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:",
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "api.db.database",
        "description": "api.db.database",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "api.db.database",
        "description": "api.db.database",
        "peekOfCode": "Base = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "api.db.database",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "api.models.models",
        "description": "api.models.models",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    password = Column(String)\n    created_at = Column(TIMESTAMP, nullable=True, server_default=text(\"now()\"))\n    updated_at = Column(TIMESTAMP, nullable=True, server_default=text(\"now()\"), onupdate=text(\"now()\"))\n    posts = relationship(\"Post\", back_populates=\"author\")\nclass Post(Base):",
        "detail": "api.models.models",
        "documentation": {}
    },
    {
        "label": "Post",
        "kind": 6,
        "importPath": "api.models.models",
        "description": "api.models.models",
        "peekOfCode": "class Post(Base):\n    __tablename__ = \"post\"\n    id = Column(Integer, primary_key=True, index=True)\n    content = Column(String)\n    author_id = Column(Integer, ForeignKey(\"users.id\"))\n    created_at = Column(TIMESTAMP, nullable=True, server_default=text(\"now\"))\n    updated_at = Column(TIMESTAMP, nullable=True,server_default=text(\"now\"), onupdate=text(\"now()\"))\n    replied_to_id = Column(Integer, ForeignKey(\"post.id\", ondelete='CASCADE'))\n    replies = Column(ARRAY(Integer), default=[])\n    author = relationship(\"User\", back_populates=\"posts\")",
        "detail": "api.models.models",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "api.routes.login",
        "description": "api.routes.login",
        "peekOfCode": "def login(user_credential: OAuth2PasswordRequestForm = Depends(OAuth2PasswordRequestForm)\n          , db: Session = Depends(database.get_db)):\n    user = db.query(models.User).filter(\n        models.User.username == user_credential.username).first()\n    print(user_credential)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=f\"user {user_credential.username} not exist\")\n    if not verify_password(user_credential.password, str(user.password)): \n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Invalid credential\")\n    access_token = create_access_token(data={\"user_id\": user.id})",
        "detail": "api.routes.login",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "api.routes.login",
        "description": "api.routes.login",
        "peekOfCode": "router = APIRouter(prefix=\"/login\", tags=[\"Login\"])\n@router.post(\"/\", response_model=Token)\ndef login(user_credential: OAuth2PasswordRequestForm = Depends(OAuth2PasswordRequestForm)\n          , db: Session = Depends(database.get_db)):\n    user = db.query(models.User).filter(\n        models.User.username == user_credential.username).first()\n    print(user_credential)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=f\"user {user_credential.username} not exist\")\n    if not verify_password(user_credential.password, str(user.password)): ",
        "detail": "api.routes.login",
        "documentation": {}
    },
    {
        "label": "get_posts",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def get_posts(current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    if current_user.id:\n        return db.query(Post).all()\n    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Unauthorized\")\n@router.post(\"/\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\ndef create_post(post: PostCreate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    if current_user.id:\n        create_post = models.Post(content=post.content, author_id=current_user.id,  author=current_user)\n        post.author_id = current_user.id\n        db.add(create_post)",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "create_post",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def create_post(post: PostCreate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    if current_user.id:\n        create_post = models.Post(content=post.content, author_id=current_user.id,  author=current_user)\n        post.author_id = current_user.id\n        db.add(create_post)\n        db.commit()\n        db.refresh(create_post)\n        return create_post\n    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Unauthorized\")\n@router.get(\"/{post_id}\", response_model=PostResponse, status_code=status.HTTP_200_OK)",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "get_post",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def get_post(post_id: int, db: Session = Depends(database.get_db)):\n    post = db.query(models.Post).filter(models.Post.id == post_id).first()\n    if post:\n        return post\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Post not found\")\n@router.delete(\"/{post_id}\")\ndef delete_post(post_id: int, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post = db.query(models.Post).filter(models.Post.id == post_id).first()\n    if post:\n        db.delete(post)",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "delete_post",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def delete_post(post_id: int, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post = db.query(models.Post).filter(models.Post.id == post_id).first()\n    if post:\n        db.delete(post)\n        db.commit()\n        return {\"url\": f\"/post/{post_id}\"}\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Post not found\")\n@router.put(\"/{post_id}\", response_model=PostResponse)\ndef update_post(post_id: int, post: PostUpdate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post_in_db = db.query(models.Post).filter(models.Post.id == post_id).first()",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "update_post",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def update_post(post_id: int, post: PostUpdate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post_in_db = db.query(models.Post).filter(models.Post.id == post_id).first()\n    if post_in_db:\n        post_in_db.content = post.content\n        db.commit()\n        return post_in_db\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Post not found\")\n@router.put(\"/reply/{post_id}\", response_model=PostResponse)\ndef reply_post(post_id: int, reply: PostCreate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post = db.query(models.Post).filter(models.Post.id == post_id).first()",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "reply_post",
        "kind": 2,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "def reply_post(post_id: int, reply: PostCreate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    post = db.query(models.Post).filter(models.Post.id == post_id).first()\n    if post:\n        reply_post = models.Post(content=reply.content, author_id=current_user.id, replied_to_id=post_id)\n        post.replies.append(reply_post.id)\n        db.add(reply_post)\n        db.commit()\n        db.refresh(reply_post)\n        db.refresh(post.replies)\n        return post",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "api.routes.post",
        "description": "api.routes.post",
        "peekOfCode": "router = APIRouter(prefix=\"/post\", tags=[\"Post\"])\n@router.get(\"/\")\ndef get_posts(current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    if current_user.id:\n        return db.query(Post).all()\n    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Unauthorized\")\n@router.post(\"/\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\ndef create_post(post: PostCreate, current_user: UserInDb = Depends(get_current_user), db: Session = Depends(database.get_db)):\n    if current_user.id:\n        create_post = models.Post(content=post.content, author_id=current_user.id,  author=current_user)",
        "detail": "api.routes.post",
        "documentation": {}
    },
    {
        "label": "get_user",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def get_user(db: Session = Depends(database.get_db), current_user: models.User = Depends(get_current_user)):\n    return current_user\n@router.post(\"/\", response_model=user.UserResponse, status_code=201)\ndef create_user(user: user.UserCreate, db: Session = Depends(database.get_db)):\n    db_user = models.User(username=user.username, email=user.email, password=hash(user.password))\n    try:\n        db.add(db_user)\n    except IntegrityError:\n        raise HTTPException(status_code=400, detail=\"Username or email already exists\")\n    finally:",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "create_user",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def create_user(user: user.UserCreate, db: Session = Depends(database.get_db)):\n    db_user = models.User(username=user.username, email=user.email, password=hash(user.password))\n    try:\n        db.add(db_user)\n    except IntegrityError:\n        raise HTTPException(status_code=400, detail=\"Username or email already exists\")\n    finally:\n        db.commit()\n        db.refresh(db_user)\n    return db_user",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "get_user_by_id",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def get_user_by_id(user_id: int, db: Session = Depends(database.get_db)):\n    user = db.query(models.User).filter(models.User.id == user_id).first()\n    if user:\n        return user\n    raise HTTPException(status_code=404, detail=\"User not found\")\n@router.delete(\"/{user_id}\")\ndef delete_user(user_id: int, db: Session = Depends(database.get_db)):\n    user = db.query(models.User).filter(models.User.id == user_id).first()\n    if user:\n        db.delete(user)",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "delete_user",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def delete_user(user_id: int, db: Session = Depends(database.get_db)):\n    user = db.query(models.User).filter(models.User.id == user_id).first()\n    if user:\n        db.delete(user)\n        db.commit()\n        return {\"url\": f\"/user/{user_id}\"}\n    raise HTTPException(status_code=404, detail=\"User not found\")\n@router.put(\"/{user_id}\", response_model=user.UserResponse)\ndef update_user(user_id: int, user: user.UserUpdate, db: Session = Depends(database.get_db)):\n    user_in_db = db.query(models.User).filter(models.User.id == user_id).first()",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "update_user",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def update_user(user_id: int, user: user.UserUpdate, db: Session = Depends(database.get_db)):\n    user_in_db = db.query(models.User).filter(models.User.id == user_id).first()\n    if user_in_db:\n        user_in_db.username = user.username\n        user_in_db.email = user.email\n        db.commit()\n        return user_in_db\n    raise HTTPException(status_code=404, detail=\"User not found\")\n@router.put(\"/change_password/{user_id}\", response_model=user.UserResponse)\ndef change_password(user_id: int, user: user.UserUpdate, db: Session = Depends(database.get_db)):",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "change_password",
        "kind": 2,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "def change_password(user_id: int, user: user.UserUpdate, db: Session = Depends(database.get_db)):\n    user_in_db = db.query(models.User).filter(models.User.id == user_id).first()\n    if user_in_db:\n        user_in_db.password = hash(user.password)\n        db.commit()\n        return user_in_db\n    raise HTTPException(status_code=404, detail=\"User not found\")",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "api.routes.user",
        "description": "api.routes.user",
        "peekOfCode": "router = APIRouter(prefix=\"/user\", tags=[\"User\"])\n@router.get(\"/me\", response_model=UserBase)\ndef get_user(db: Session = Depends(database.get_db), current_user: models.User = Depends(get_current_user)):\n    return current_user\n@router.post(\"/\", response_model=user.UserResponse, status_code=201)\ndef create_user(user: user.UserCreate, db: Session = Depends(database.get_db)):\n    db_user = models.User(username=user.username, email=user.email, password=hash(user.password))\n    try:\n        db.add(db_user)\n    except IntegrityError:",
        "detail": "api.routes.user",
        "documentation": {}
    },
    {
        "label": "PostBase",
        "kind": 6,
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "peekOfCode": "class PostBase(BaseModel):\n    author_id: int\n    author: Optional[UserResponse]\n    content: str\n    created_at: Optional[datetime]\n    updated_at: Optional[datetime]\nclass PostCreate(PostBase):\n    replied_to_id: Optional[int]\n    pass\nclass PostUpdate(BaseModel):",
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "PostCreate",
        "kind": 6,
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "peekOfCode": "class PostCreate(PostBase):\n    replied_to_id: Optional[int]\n    pass\nclass PostUpdate(BaseModel):\n    content: str\nclass PostResponse(PostBase):\n    id: int\n    replied_to_id: Optional[int]\n    replies: Optional[list[int]]\n    # user: Optional[UserResponse]",
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "PostUpdate",
        "kind": 6,
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "peekOfCode": "class PostUpdate(BaseModel):\n    content: str\nclass PostResponse(PostBase):\n    id: int\n    replied_to_id: Optional[int]\n    replies: Optional[list[int]]\n    # user: Optional[UserResponse]\nclass PostInDb(PostResponse):\n    pass",
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "PostResponse",
        "kind": 6,
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "peekOfCode": "class PostResponse(PostBase):\n    id: int\n    replied_to_id: Optional[int]\n    replies: Optional[list[int]]\n    # user: Optional[UserResponse]\nclass PostInDb(PostResponse):\n    pass",
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "PostInDb",
        "kind": 6,
        "importPath": "api.schemas.post",
        "description": "api.schemas.post",
        "peekOfCode": "class PostInDb(PostResponse):\n    pass",
        "detail": "api.schemas.post",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "peekOfCode": "class Token(BaseModel):\n    access_token: str\n    token_type: str\nclass TokenData(BaseModel):\n    id: int = None",
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "TokenData",
        "kind": 6,
        "importPath": "api.schemas.token",
        "description": "api.schemas.token",
        "peekOfCode": "class TokenData(BaseModel):\n    id: int = None",
        "detail": "api.schemas.token",
        "documentation": {}
    },
    {
        "label": "UserBase",
        "kind": 6,
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "peekOfCode": "class UserBase(BaseModel):\n    username: str\n    email: EmailStr\n    created_at: Optional[datetime]\n    updated_at: Optional[datetime]\nclass UserCreate(UserBase):\n    password: str\nclass UserResponse(UserBase):\n    id: int\n    pass",
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserCreate",
        "kind": 6,
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "peekOfCode": "class UserCreate(UserBase):\n    password: str\nclass UserResponse(UserBase):\n    id: int\n    pass\nclass UserInDb(UserBase):\n    password: str\nclass UserUpdate(UserBase):\n    password: Optional[str] = None",
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserResponse",
        "kind": 6,
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "peekOfCode": "class UserResponse(UserBase):\n    id: int\n    pass\nclass UserInDb(UserBase):\n    password: str\nclass UserUpdate(UserBase):\n    password: Optional[str] = None",
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserInDb",
        "kind": 6,
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "peekOfCode": "class UserInDb(UserBase):\n    password: str\nclass UserUpdate(UserBase):\n    password: Optional[str] = None",
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "UserUpdate",
        "kind": 6,
        "importPath": "api.schemas.user",
        "description": "api.schemas.user",
        "peekOfCode": "class UserUpdate(UserBase):\n    password: Optional[str] = None",
        "detail": "api.schemas.user",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "hash",
        "kind": 2,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "def hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\ndef verify_access_token(token: str, credential_exception):\n    try:",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "kind": 2,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "def create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\ndef verify_access_token(token: str, credential_exception):\n    try:\n        payload = jwt.decode(token=token, key=SECRET_KEY, algorithms=ALGORITHM)\n        id :str = payload.get(\"user_id\") #type: ignore",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "verify_access_token",
        "kind": 2,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "def verify_access_token(token: str, credential_exception):\n    try:\n        payload = jwt.decode(token=token, key=SECRET_KEY, algorithms=ALGORITHM)\n        id :str = payload.get(\"user_id\") #type: ignore\n        if id is None:\n            raise credential_exception\n        token_data = TokenData(id=id)\n    except JWTError:\n        raise credential_exception\n    return token_data",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "def get_current_user(token: TokenData = Depends(oauth2_schemes),\n                     db: Session = Depends(database.get_db)):\n    credential_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,\n                                         detail=\"Couldn't validate credential\",\n                                         headers={\"WWW-Authenticate\":\"Bearer\"})\n    token = verify_access_token(token, credential_exception)  #type: ignore\n    user = db.query(models.User).filter(models.User.id == token.id).first()\n    return user",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "oauth2_schemes",
        "kind": 5,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "oauth2_schemes = OAuth2PasswordBearer(tokenUrl=\"login\")\nSECRET_KEY = settings.secret_key\nALGORITHM = settings.algorithm\nACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "SECRET_KEY = settings.secret_key\nALGORITHM = settings.algorithm\nACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "ALGORITHM = settings.algorithm\nACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "api.utils.auth",
        "description": "api.utils.auth",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\ndef hash(password: str):\n    return pwd_context.hash(password)\ndef create_access_token(data: dict):\n    to_encode = data.copy() # type: ignore\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)",
        "detail": "api.utils.auth",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "class Settings(BaseSettings):\n    database_hostname: str\n    database_port: str\n    database_password: str\n    database_name: str\n    database_username: str\n    database_url: str\n    secret_key: str\n    algorithm: str\n    access_token_expire_minutes: int",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "api.config",
        "description": "api.config",
        "peekOfCode": "settings = Settings()\nif __name__ == \"__main__\":\n    print(settings)",
        "detail": "api.config",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def root():\n    return RedirectResponse(url=\"/docs\")\nif __name__ == \"__main__\":\n    uvicorn.run(app=\"main:app\", host=\"localhost\", port=8000, reload=True)\n#Users API",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "app = FastAPI()\norigins = [\n    \"*\",\n    \"http://localhost\"\n]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "origins",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "origins = [\n    \"*\",\n    \"http://localhost\"\n]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "TodoInDB",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class TodoInDB(SQL_BASE):  # type: ignore\n    __tablename__ = \"todo\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    key = Column(String(length=128), nullable=False, unique=True)\n    value = Column(String(length=128), nullable=False)\n    done = Column(Boolean, default=False)\nclass Todo(BaseModel):\n    key: str\n    value: str\n    done: bool = False",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "Todo",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class Todo(BaseModel):\n    key: str\n    value: str\n    done: bool = False\nclass TodoFilter(BaseModel):\n    limit: Optional[int] = None\n    key_contains: Optional[str] = None\n    value_contains: Optional[str] = None\n    done: Optional[bool] = None\nclass TodoRepository:  # Interface",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "TodoFilter",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class TodoFilter(BaseModel):\n    limit: Optional[int] = None\n    key_contains: Optional[str] = None\n    value_contains: Optional[str] = None\n    done: Optional[bool] = None\nclass TodoRepository:  # Interface\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "TodoRepository",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class TodoRepository:  # Interface\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n    def save(self, todo: Todo) -> None:\n        raise NotImplementedError()\n    def get_by_key(self, key: str) -> Optional[Todo]:\n        raise NotImplementedError()\n    def get(self, todo_filter: TodoFilter) -> List[Todo]:",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "InMemoryTodoRepository",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class InMemoryTodoRepository:  # In-memory implementation of interface\n    def __init__(self):\n        self.data = {}\n    def save(self, todo: Todo) -> None:\n        self.data[todo.key] = todo\n    def get_by_key(self, key: str) -> Optional[Todo]:\n        return self.data.get(key)\n    def get(self, todo_filter: TodoFilter) -> List[Todo]:\n        all_matching_todos = filter(\n            lambda todo: (not todo_filter.key_contains or todo_filter.key_contains in todo.key)",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "SQLTodoRepository",
        "kind": 6,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "class SQLTodoRepository(TodoRepository):  # SQL Implementation of interface\n    def __init__(self, session):\n        self._session: Session = session\n    def __exit__(self, exc_type, exc_value: str, exc_traceback: str) -> None:\n        if any([exc_type, exc_value, exc_traceback]):\n            self._session.rollback()\n            return\n        try:\n            self._session.commit()\n        except DatabaseError as e:",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "get_engine",
        "kind": 2,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "def get_engine(db_string: str):\n    return create_engine(db_string, pool_pre_ping=True)\nclass TodoInDB(SQL_BASE):  # type: ignore\n    __tablename__ = \"todo\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    key = Column(String(length=128), nullable=False, unique=True)\n    value = Column(String(length=128), nullable=False)\n    done = Column(Boolean, default=False)\nclass Todo(BaseModel):\n    key: str",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "create_todo_repository",
        "kind": 2,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "def create_todo_repository() -> Iterator[TodoRepository]:\n    session = sessionmaker(bind=get_engine(os.getenv(\"DB_STRING\")))()\n    todo_repository = SQLTodoRepository(session)\n    try:\n        yield todo_repository\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "SQL_BASE",
        "kind": 5,
        "importPath": "api.repository",
        "description": "api.repository",
        "peekOfCode": "SQL_BASE = declarative_base()\n@lru_cache(maxsize=None)\ndef get_engine(db_string: str):\n    return create_engine(db_string, pool_pre_ping=True)\nclass TodoInDB(SQL_BASE):  # type: ignore\n    __tablename__ = \"todo\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    key = Column(String(length=128), nullable=False, unique=True)\n    value = Column(String(length=128), nullable=False)\n    done = Column(Boolean, default=False)",
        "detail": "api.repository",
        "documentation": {}
    },
    {
        "label": "fake_todo_repository",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def fake_todo_repository():\n    return InMemoryTodoRepository()\n@pytest.fixture\ndef todo_repository():\n    time.sleep(1)\n    alembicArgs = [\"--raiseerr\", \"upgrade\", \"head\"]\n    alembic.config.main(argv=alembicArgs)\n    engine = get_engine(os.getenv(\"DB_STRING\"))\n    session = sessionmaker(bind=engine)()\n    yield SQLTodoRepository(session)",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "todo_repository",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def todo_repository():\n    time.sleep(1)\n    alembicArgs = [\"--raiseerr\", \"upgrade\", \"head\"]\n    alembic.config.main(argv=alembicArgs)\n    engine = get_engine(os.getenv(\"DB_STRING\"))\n    session = sessionmaker(bind=engine)()\n    yield SQLTodoRepository(session)\n    session.close()\n    sessionmaker(bind=engine, autocommit=True)().execute(\n        \";\".join([f\"TRUNCATE TABLE {t} CASCADE\" for t in SQL_BASE.metadata.tables.keys()])",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "test_example_unit_test",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def test_example_unit_test():\n    assert 1 != 0\n@pytest.mark.integration\ndef test_contract_test(fake_todo_repository: TodoRepository, todo_repository: TodoRepository):\n    \"\"\"See https://martinfowler.com/bliki/ContractTest.html\"\"\"\n    todo = Todo(key=\"testkey\", value=\"testvalue\")\n    for repo in [fake_todo_repository, todo_repository]:\n        repo.save(todo)\n        new_todo = repo.get_by_key(\"testkey\")\n        assert new_todo and new_todo.value == \"testvalue\"",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "test_contract_test",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def test_contract_test(fake_todo_repository: TodoRepository, todo_repository: TodoRepository):\n    \"\"\"See https://martinfowler.com/bliki/ContractTest.html\"\"\"\n    todo = Todo(key=\"testkey\", value=\"testvalue\")\n    for repo in [fake_todo_repository, todo_repository]:\n        repo.save(todo)\n        new_todo = repo.get_by_key(\"testkey\")\n        assert new_todo and new_todo.value == \"testvalue\"\n        assert len(repo.get(TodoFilter(key_contains=\"e\"))) == 1\n        assert len(repo.get(TodoFilter(key_contains=\"e\", limit=0))) == 0\n        assert len(repo.get(TodoFilter(key_contains=\"v\"))) == 0",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "test_repository",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def test_repository(todo_repository: SQLTodoRepository):\n    with todo_repository as r:\n        r.save(Todo(key=\"testkey\", value=\"testvalue\"))\n    todo = r.get_by_key(\"testkey\")\n    assert todo.value == \"testvalue\"\n    with pytest.raises(IntegrityError):\n        with todo_repository as r:\n            r.save(Todo(key=\"testkey\", value=\"not allowed: unique todo keys!\"))\n    with pytest.raises(DataError):\n        with todo_repository as r:",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "test_repository_filter",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def test_repository_filter(todo_repository: SQLTodoRepository):\n    with todo_repository as repo:\n        repo.save(Todo(key=\"testkey\", value=\"testvalue\"))\n        repo.save(Todo(key=\"abcde\", value=\"v\"))\n    todos = repo.get(TodoFilter(key_contains=\"test\"))\n    assert len(todos) == 1\n    assert todos[0].value == \"testvalue\"\n    todos = repo.get(TodoFilter(key_contains=\"abcde\"))\n    assert len(todos) == 1\n    assert todos[0].value == \"v\"",
        "detail": "api.test_all",
        "documentation": {}
    },
    {
        "label": "test_api",
        "kind": 2,
        "importPath": "api.test_all",
        "description": "api.test_all",
        "peekOfCode": "def test_api():\n    time.sleep(1)\n    client = TestClient(app)\n    response = client.post(\"/create/testkey?value=testvalue\")\n    assert response.status_code == 201\n    response = client.get(\"/get/testkey\")\n    assert response.status_code == 200\n    assert response.json() == {\"key\": \"testkey\", \"value\": \"testvalue\", \"done\": False}\n    response = client.get(\"/get/wrong\")\n    assert response.status_code == 404",
        "detail": "api.test_all",
        "documentation": {}
    }
]